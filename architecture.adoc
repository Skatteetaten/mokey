= Architecture

= Introduction

Mokey is an application that collects data about running applications on an Aurora OpenShift cluster and caches this in a Redis datastore. The key for the cache is ApplicationId.

The collection process is scheduled and parallelized, and information about the applications is updated in real time as
the process progresses.

This document is a description of the overall architecture of the module, divided into two main sections;
<<core-concepts, the Core Concepts>> and <<api-resources, the API resources>>, describing the internal aspects of the
module, and the externally exposed resources, respectively.


[[core-concepts]]
= Core Concepts (Internal)

This section contains a description of the core concepts of the module, with implementation and domain model details.
It does not contain any details of the resources that are exposed from the API, only the classes and objects that are
used to support the internal data collection workflow; crawling.

[[reference-data]]
== Reference Data


[[application-data]]
== Application Data

All pieces of relevant data for an application based on the needs of the clients of the API. The data is collected from
the Aurora OpenShift cluster, or calculated from it. Intended as an internal representation to be used as a base for
external resources. 

If retrieving some external resource failes this needs to be modeled as data that will be cache. Lets say we have a health check. If this times out there must be information about this that is cached. This can be modeled as an Either<Failure,T> where Failure has a status code and a message and T is the given type for the resource you want to fetch.

Package: no.skatteetaten.aurora.mokey.model

[[collected-data]]
=== Collected Data

Classes that represent data collected from the cluster for an application.

ApplicationId:: name and Environment
Environment:: name and an affiliation.
ApplicationData:: Container object for all data collected for a given application. Gives access to calculated entities
via properties.
InstanceData: For each instance of an application we need information about management interface and /info /health of that managementInterface

=== Calculated Entities

Classes that represent concepts calculated from the <<collected-data, Collected Data>>.

AuroraStatus:: The representation of the application status based on data collected from OpenShift and from the
application itself from its Management Interface (ref needed).


[[cache]]
== Cache

Used for generating API responses based on the ApplicationData. The cache contains an ApplicationData entry for each
application running on the cluster and is populated by the Crawler (described next).
Note that we need a seperate entity for the cache, it might be sensible to structure this differently then the internal representation and we are more robust regarding internal changes.


== Crawler

The core workflow for collecting Application Data from the Aurora OpenShift cluster and updating the Cache with the
collected data.

The Crawler starts by collecting a handle for each application running on the cluster, and then collects information for
those applications in parallel. The collected information per application is called Application Data and the Cache
is updated individually for each application as the collection process progresses. AuroraStatus is calculated at the same time and exposed as a metric

Upon completion of a crawl of the cluster, the Cache is updated to remove entries for applications that no longer exist.

=== Implementation Details
ApplicationDataCrawler:: Responsible for the core parallelized data collection workflow. Does not collect any data
by itself and does not know of any of the underlying details of OpenShift or OpenShift objects. Handles parallelization
and *triggering* of data collection and cache update. Workflow component.

ApplicationDataService:: Responsible for collecting <<application-data, Application Data>> given an <<ApplicationId>>.
Knows of OpenShift objects, but not how to collect them (done via OpenShiftService). Also knows how to identify which
applications are currently running on the cluster.

AuroraStatusCalculator:: Service object for determining the AuroraStatus for an application. Configured with different
kinds of thresholds that affect status transitions (AVERAGE_RESTART_OBSERVE_THRESHOLD, AVERAGE_RESTART_ERROR_THRESHOLD,
DIFFERENT_DEPLOYMENT_HOUR_THRESHOLD).

ApplicationManagementService:: Service that talks to Red fraggle to get management information about instances of an application.

OpenShiftService:: Low level communication and serialization handling.

== Crawler Schedule

Triggers the Crawler based on a configurable schedule (periodic).


== Interactions
Mokey populates a Redis data store with data. 
Gobo fetches information from that Redis to expose to Console/Wallboard/Truesight/whatever
Mokey calls Red (url might be in different cluster) to fetch information from running instances
Clerk (suggested new name for Auditor fraggle) reads cached data from Gobo/redis and checks for NFR
